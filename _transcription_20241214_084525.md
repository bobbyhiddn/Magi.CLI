# Directory: 

## /spellcraft/

/spellcraft/sigildry.py: 
```
#!/usr/bin/env python3

import os
import random
import math
import svgwrite
import hashlib
from pathlib import Path
from typing import Dict, Any, Optional, Union
import json
import yaml
import tempfile
import zipfile
from enum import Enum

from magi_cli.spells import SANCTUM_PATH

class SpellType(Enum):
    SCRIPT = 'script'
    BUNDLE = 'bundle'

class ShellType(Enum):
    PYTHON = 'python'
    BASH = 'bash'

class Sigildry:
    """
    Handles sigil (cryptographic signature) generation, verification, 
    and management for Magi spells.
    """
    
    # Rune sets from SpellBundle
    ELDER_FUTHARK = [
        "ᚠ", "ᚢ", "ᚦ", "ᚨ", "ᚱ", "ᚲ", "ᚷ", "ᚹ", "ᚺ", "ᚾ", "ᛁ", "ᛃ", "ᛇ", "ᛈ", "ᛉ", "ᛊ",
        "ᛏ", "ᛒ", "ᛖ", "ᛗ", "ᛚ", "ᛜ", "ᛞ", "ᛟ"
    ]
    
    YOUNGER_FUTHARK = [
        "ᚠ", "ᚢ", "ᚦ", "ᚬ", "ᚱ", "ᚴ", "ᚼ", "ᚾ", "ᛁ", "ᛅ", "ᛋ", "ᛏ", "ᛒ", "ᛘ", "ᛚ", "ᛦ"
    ]
    
    MEDIEVAL_RUNES = [
        "ᛆ", "ᛒ", "ᛍ", "ᛑ", "ᛂ", "ᛓ", "ᛄ", "ᚻ", "ᛌ", "ᛕ", "ᛖ", "ᛗ", "ᚿ", "ᚮ", "ᛔ", "ᛩ",
        "ᛪ", "ᚱ", "ᛌ", "ᛐ", "ᚢ", "ᚡ", "ᚥ", "ᛨ"
    ]
    
    OGHAM = [
        "ᚁ", "ᚂ", "ᚃ", "ᚄ", "ᚅ", "ᚆ", "ᚇ", "ᚈ", "ᚉ", "ᚊ", "ᚋ", "ᚌ", "ᚍ", "ᚎ", "ᚏ", "ᚐ",
        "ᚑ", "ᚒ", "ᚓ", "ᚔ", "ᚕ"
    ]
    
    ALL_RUNES = ELDER_FUTHARK + YOUNGER_FUTHARK + MEDIEVAL_RUNES + OGHAM

    def _hash_to_params(self, hash_input: str) -> dict:
        """Convert hash to visualization parameters."""
        num_lines = int(hash_input[:2], 16) % 6 + 5
        min_runes = int(hash_input[2:4], 16) % 2 + 1
        max_runes = int(hash_input[4:6], 16) % 2 + 2
        
        angles = []
        available_sectors = list(range(0, 360, 36))
        for i in range(num_lines):
            hash_segment = int(hash_input[i*2:i*2+2], 16)
            sector_index = hash_segment % len(available_sectors)
            base_angle = available_sectors.pop(sector_index)
            jitter = int(hash_input[i*2+2:i*2+4], 16) % 20 - 10
            angles.append(base_angle + jitter)
        
        return {
            'num_lines': num_lines,
            'min_runes': min_runes,
            'max_runes': max_runes,
            'angles': angles
        }

    def _calculate_rune_position(self, center: int, radius: int, angle: float) -> tuple:
        """Calculate position for a rune based on radius and angle."""
        x = center + math.cos(math.radians(angle)) * radius
        y = center + math.sin(math.radians(angle)) * radius
        return (x, y)

    def generate_sigil(self, hash_input: str, output_path: Path, size: int = 256) -> None:
        """Generate a spell sigil SVG with enhanced starburst pattern."""
        center = size // 2
        ring_width = 10
        outer_radius = center - 20
        inner_radius = outer_radius - ring_width
        
        dwg = svgwrite.Drawing(output_path, size=(size, size))
        dwg.add(dwg.rect(insert=(0, 0), size=(size, size), fill="white"))
        
        params = self._hash_to_params(hash_input)
        
        # Generate random color
        circle_color = f"#{hash_input[6:12]}"

        # Add stone grey background between circles
        dwg.add(dwg.circle(center=(center, center), r=outer_radius, fill="#E0E0E0", stroke="none"))
        dwg.add(dwg.circle(center=(center, center), r=inner_radius, fill=circle_color, stroke="none"))
        
        # Add boundary circles
        for radius in (outer_radius, inner_radius):
            dwg.add(dwg.circle(
                center=(center, center),
                r=radius,
                stroke="black",
                stroke_width=1,
                fill="none"
            ))
        
        # Generate outer rim runes
        self._generate_outer_rim(dwg, hash_input, center, outer_radius, ring_width)
        
        # Generate starburst pattern
        self._generate_starburst(dwg, hash_input, center, params, inner_radius)
        
        # Add center rune
        self._generate_center_rune(dwg, hash_input, center, size)
        
        dwg.save()

    def _generate_outer_rim(self, dwg, hash_input: str, center: int, radius: int, ring_width: int) -> None:
        """Generate outer rim with mixed runes."""
        adjusted_radius = radius - (ring_width * 0.6)
        circumference = 2 * math.pi * adjusted_radius
        font_size = 5
        spacing_factor = 1.1
        num_runes = int(circumference / (font_size * spacing_factor))
        
        rune_indices = [int(hash_input[i:i+2], 16) % len(self.ALL_RUNES) 
                       for i in range(0, len(hash_input), 2)]
        rune_mappings = [{"rune": self.ALL_RUNES[idx], 
                         "rotation": (int(hash_input[i:i+2], 16) % 360)}
                        for i, idx in enumerate(rune_indices)]
        
        rune_mappings = (rune_mappings * (num_runes // len(rune_mappings) + 1))[:num_runes]
        
        angle_step = 360 / num_runes
        for i, rune_data in enumerate(rune_mappings):
            angle = i * angle_step
            x, y = self._calculate_rune_position(center, adjusted_radius, angle)
            dwg.add(dwg.text(
                rune_data["rune"],
                insert=(x, y),
                text_anchor="middle",
                alignment_baseline="middle",
                font_size=5,
                transform=f"rotate({rune_data['rotation'] + angle},{x},{y})"
            ))

    def _generate_starburst(self, dwg, hash_input: str, center: int, params: dict, inner_radius: int) -> None:
        """Generate starburst pattern with variable runes on each line."""
        center_clear_radius = inner_radius * 0.4
        line_end_radius = inner_radius
        
        for i, angle in enumerate(params['angles']):
            start_x, start_y = self._calculate_rune_position(center, center_clear_radius, angle)
            end_x, end_y = self._calculate_rune_position(center, line_end_radius, angle)
            
            dwg.add(dwg.line(start=(start_x, start_y), end=(end_x, end_y),
                            stroke='black', stroke_width=2))
            
            self._add_runes_to_line(dwg, hash_input, center, i, angle, params,
                                  center_clear_radius, line_end_radius)

    def _add_runes_to_line(self, dwg, hash_input, center, i, angle, params,
                          start_radius, end_radius):
        """Add runes along a starburst line."""
        available_length = end_radius - start_radius
        hash_segment = int(hash_input[i*2:i*2+2], 16)
        num_runes = params['min_runes'] + (hash_segment % (params['max_runes'] - params['min_runes'] + 1))
        segment_length = available_length / (num_runes + 1)
        
        for j in range(num_runes):
            radius = start_radius + segment_length * (j + 1)
            if j == num_runes - 1:
                radius = min(radius, end_radius - 5)
            x, y = self._calculate_rune_position(center, radius, angle)
            
            rune_idx = (int(hash_input[(i+j)%32:(i+j)%32+2], 16) % len(self.OGHAM))
            rune = self.OGHAM[rune_idx]
            
            dwg.add(dwg.text(
                rune,
                insert=(x, y),
                text_anchor="middle",
                alignment_baseline="middle",
                font_size=14,
                transform=f"rotate({angle},{x},{y})"
            ))

    def _generate_center_rune(self, dwg, hash_input: str, center: int, size: int):
        """Generate a single centered rune."""
        rune_index = int(hash_input[:2], 16) % len(self.ALL_RUNES)
        rune = self.ALL_RUNES[rune_index]
        
        dwg.add(dwg.text(
            rune,
            insert=(center, center + 8),
            text_anchor="middle",
            alignment_baseline="middle",
            font_size=70,
        ))

    @staticmethod
    def generate_sigil_hash(
        spell_name: str,
        description: str,
        spell_type: Union[SpellType, str],
        version: str,
        entry_point: str,
        shell_type: Union[ShellType, str],
        spell_dir: Path
    ) -> str:
        """
        Generate a hash for a spell's sigil.
        
        Args:
            spell_name (str): Name of the spell
            description (str): Description of the spell
            spell_type (Union[SpellType, str]): Type of spell
            version (str): Version of the spell
            entry_point (str): Entry point file path
            shell_type (Union[ShellType, str]): Shell type for the spell
            spell_dir (Path): Directory containing spell files
            
        Returns:
            str: Generated hash for the sigil
        """
        # Normalize types
        if isinstance(spell_type, str):
            spell_type = getattr(SpellType, spell_type.upper(), SpellType.SCRIPT)
        if isinstance(shell_type, str):
            shell_type = getattr(ShellType, shell_type.upper(), ShellType.PYTHON)

        # Create hasher
        hasher = hashlib.sha256()

        # Add metadata to hash in a consistent order
        metadata_str = f"{spell_name}\n{description}\n{spell_type}\n{version}\n{entry_point}\n{shell_type}"
        hasher.update(metadata_str.encode())

        # Add file contents to hash in a consistent order
        for file_path in sorted(spell_dir.rglob('*')):
            if file_path.is_file():
                # Skip metadata and sigil files
                if file_path.name in ['spell.json', 'spell.yaml'] or file_path.name.endswith('_sigil.svg'):
                    continue
                    
                # Get relative path for consistent hashing
                rel_path = file_path.relative_to(spell_dir)
                hasher.update(str(rel_path).encode())
                
                # Add file contents
                with open(file_path, 'rb') as f:
                    while chunk := f.read(8192):
                        hasher.update(chunk)

        return hasher.hexdigest()

    @staticmethod
    def generate_sigil_from_spell(
        spell_path: Path, 
        sigil_hash: Optional[str] = None,
        output_path: Optional[Path] = None
    ) -> Optional[Path]:
        """
        Generate sigil for a given spell.
        
        Args:
            spell_path (Path): Path to the spell
            sigil_hash (Optional[str]): Predefined hash for sigil generation
            output_path (Optional[Path]): Custom output path for sigil
        
        Returns:
            Path: Path to the generated sigil SVG
        """
        # This method requires metadata from the spell
        # Implement a generic way to extract spell metadata without SpellBundle
        try:
            # Placeholder for spell metadata extraction
            # You might want to implement a generic metadata extraction method
            metadata = {
                'name': spell_path.stem,
                'description': f'Spell at {spell_path}',
                'type': 'generic'
            }
            
            # Generate hash if not provided
            if sigil_hash is None:
                sigil_hash = Sigildry.generate_sigil_hash(
                    metadata['name'], 
                    metadata.get('description', ''), 
                    metadata.get('type', 'unknown')
                )
            
            # Determine sigil path
            if output_path is None:
                output_path = spell_path.parent / f"{metadata['name']}_sigil.svg"
            
            # Generate sigil
            sigildry = Sigildry()
            sigildry.generate_sigil(sigil_hash, output_path)
            
            return output_path
        
        except Exception as e:
            print(f"Error generating sigil: {e}")
            return None

    @staticmethod
    def verify_sigil(
        spell_path: Path, 
        verbose: bool = False
    ) -> Dict[str, Any]:
        """
        Verify the integrity of a spell using its sigil.
        
        Args:
            spell_path (Path): Path to the spell bundle
            verbose (bool, optional): Enable detailed logging. Defaults to False.
        
        Returns:
            Dict[str, Any]: Verification details with 'verified' key
        """
        try:
            # Unpack the spell bundle
            with tempfile.TemporaryDirectory() as temp_dir:
                temp_dir_path = Path(temp_dir)
                
                # Extract spell contents
                with zipfile.ZipFile(spell_path, 'r') as zip_ref:
                    # Extract all files except spell.json and sigil
                    for file_info in zip_ref.filelist:
                        if file_info.filename not in ['spell.json', f"{Path(spell_path).stem}_sigil.svg"]:
                            zip_ref.extract(file_info, temp_dir_path)
                    
                    # Load metadata from spell.json (primary source)
                    metadata = {}
                    with zip_ref.open('spell.json') as f:
                        metadata = json.load(f)
                
                # If no metadata found at all
                if not metadata:
                    if verbose:
                        print(f"No metadata found in {spell_path}")
                    return {
                        'verified': False,
                        'error': 'No metadata found',
                        'metadata': {}
                    }
                
                # Get stored hash from metadata
                stored_hash = metadata.get('sigil_hash')
                if not stored_hash:
                    if verbose:
                        print("No stored hash found in metadata")
                    return {
                        'verified': False,
                        'error': 'No stored hash found',
                        'metadata': metadata
                    }
                
                # Calculate current hash using the same process as bundle creation
                current_hash = Sigildry.generate_sigil_hash(
                    spell_name=metadata.get('name', ''),
                    description=metadata.get('description', ''),
                    spell_type=metadata.get('type', 'generic'),
                    version=metadata.get('version', '1.0.0'),
                    entry_point=metadata.get('entry_point', ''),
                    shell_type=metadata.get('shell_type', ''),
                    spell_dir=temp_dir_path
                )
                
                if verbose:
                    print(f"Verifying sigil hash:")
                    print(f"  Stored:  {stored_hash}")
                    print(f"  Current: {current_hash}")
                
                if current_hash != stored_hash:
                    print(f"Sigil hash mismatch! Spell has been tampered with.\nStored: {stored_hash}\nCurrent: {current_hash}")
                    import sys
                    sys.exit(1)

                return {
                    'verified': True,
                    'verification_status': 'Verified',
                    'metadata': metadata,
                    'current_hash': current_hash,
                    'stored_hash': stored_hash
                }

        except Exception as e:
            if verbose:
                print(f"Sigil verification failed: {e}")
            return {
                'verified': False,
                'error': str(e),
                'verification_status': 'Verification Error',
                'metadata': {}
            }

    @staticmethod
    def check_spell_conflict(
        spell_path: Path, 
        tome_path: Optional[Path] = None,
        allow_overwrite: bool = False
    ) -> Dict[str, Any]:
        """
        Check for potential spell conflicts.
        
        Args:
            spell_path (Path): Path to the new spell
            tome_path (Optional[Path]): Path to the spell tome
            allow_overwrite (bool): Whether to allow overwriting existing spells
        
        Returns:
            Dict containing conflict information
        """
        tome_path = tome_path or Path(SANCTUM_PATH) / '.tome'
        
        # Placeholder for spell metadata extraction
        metadata = {
            'name': spell_path.stem,
            'description': f'Spell at {spell_path}',
            'type': 'generic'
        }
        spell_name = metadata['name']
        
        # Check for existing spell with same name
        existing_spell_path = tome_path / f"{spell_name}.spell"
        
        if existing_spell_path.exists():
            # Verify sigils
            new_verification = Sigildry.verify_sigil(spell_path)
            existing_verification = Sigildry.verify_sigil(existing_spell_path)
            
            return {
                'conflict': True,
                'spell_name': spell_name,
                'new_spell_details': new_verification,
                'existing_spell_details': existing_verification,
                'allow_overwrite': allow_overwrite
            }
        
        return {
            'conflict': False,
            'spell_name': spell_name,
            'metadata': metadata
        }

```
/spellcraft/spell_builder.py: 
```
#!/usr/bin/env python3

import yaml
import shutil
import tempfile
import requests
import subprocess
from pathlib import Path
from typing import Dict, Any, Optional
from magi_cli.modules.spell_bundle import SpellBundle
from magi_cli.spells import SANCTUM_PATH

class SpellBuilder:
   def __init__(self, yaml_path: Path):
       self.yaml_path = yaml_path
       self.temp_dir = Path(tempfile.mkdtemp(prefix='spell_builder_'))
       self.tome_dir = Path(SANCTUM_PATH) / '.tome'
       self.tome_dir.mkdir(parents=True, exist_ok=True)

   def create_spell_structure(self, spell_dir: Path) -> None:
       with open(self.yaml_path) as f:
           config = yaml.safe_load(f)

       spell_subdir = spell_dir / 'spell'
       artifacts_dir = spell_dir / 'artifacts'
       spell_subdir.mkdir(parents=True)
       artifacts_dir.mkdir(parents=True)

       if 'code' in config:
           entry_point = config.get('entry_point', 'main.py')
           script_path = spell_subdir / entry_point
           print(f"  Adding: spell\\{entry_point}")
           script_path.write_text(config['code'])
           if config.get('shell_type') != 'python':
               script_path.chmod(0o755)

       # Handle dependencies consistently
       dependencies = {}
       if 'requires' in config:
           dependencies['python'] = config['requires'] if isinstance(config['requires'], list) else [config['requires']]
       elif 'dependencies' in config:
           dependencies = config['dependencies']

       spell_yaml = {
           'name': config['name'],
           'description': config['description'],
           'type': 'bundled',
           'shell_type': config.get('shell_type', 'python'), 
           'version': config.get('version', '1.0.0'),
           'entry_point': config.get('entry_point', 'main.py'),
           'dependencies': dependencies
       }

       yaml_path = spell_subdir / 'spell.yaml'
       print(f"  Adding: spell\\spell.yaml")
       with open(yaml_path, 'w') as f:
           yaml.safe_dump(spell_yaml, f, default_flow_style=False)

       if 'artifacts' in config:
           for artifact in config['artifacts']:
               self._fetch_artifact(artifact, spell_dir)
               print(f"  Adding: artifacts\\{artifact['path']}")

   def _fetch_artifact(self, artifact_config: Dict[str, Any], base_path: Path) -> None:
       path = base_path / 'artifacts' / artifact_config['path']
       path.parent.mkdir(parents=True, exist_ok=True)

       if 'content' in artifact_config:
           path.write_text(artifact_config['content'])
           if path.parts[-2] == 'templates' and path.suffix == '.html':
               template_dir = base_path / 'spell' / 'templates'
               template_dir.mkdir(parents=True, exist_ok=True)
               shutil.copy2(path, template_dir / path.name)
           return

       if 'source' not in artifact_config:
           raise ValueError(f"Artifact {path} must have either 'content' or 'source'")

       source = artifact_config['source']
       source_type = source['type']
       location = source['location']

       if source_type == 'url':
           response = requests.get(location)
           response.raise_for_status()
           path.write_bytes(response.content)
       elif source_type == 'file':
           source_path = Path(location).expanduser().resolve()
           if not source_path.exists():
               raise FileNotFoundError(f"Local file not found: {source_path}")
           shutil.copy2(source_path, path)
       elif source_type == 'curl':
           headers = source.get('headers', {})
           cmd = ['curl', '-L', '-o', str(path)] + sum([['-H', f'{k}: {v}'] for k, v in headers.items()], []) + [location]
           subprocess.run(cmd, check=True)
       else:
           raise ValueError(f"Unknown source type: {source_type}")

   def build(self) -> Path:
       yaml_path = self.yaml_path
       if yaml_path.is_dir():
           yaml_path = yaml_path / 'spell' / 'spell.yaml'
           if not yaml_path.exists():
               yaml_path = self.yaml_path / 'spell.yaml'

       with open(yaml_path) as f:
           config = yaml.safe_load(f)

       spell_dir = self.temp_dir / f"{config['name']}.spell"
       print("- Adding files to bundle:")
       self.create_spell_structure(spell_dir)

       bundle = SpellBundle(spell_dir)
       return bundle.create_bundle(self.tome_dir)

   def __del__(self):
       if self.temp_dir and self.temp_dir.exists():
           shutil.rmtree(self.temp_dir)
```
/spellcraft/spell_bundle.py: 
```
import yaml
import zipfile
import tempfile
import json
import shutil
import math
import svgwrite
from datetime import datetime
from pathlib import Path
from io import BytesIO
from typing import Optional, Dict, Any, Tuple, List, Union, Literal
import hashlib
from enum import Enum
import os
from magi_cli.spells import SANCTUM_PATH
from magi_cli.loci.sigildry import Sigildry

class SpellType(str, Enum):
    BUNDLED = "bundled"
    SCRIPT = "script"
    MACRO = "macro"

class ShellType(str, Enum):
    PYTHON = "python"
    BASH = "bash"

class SpellBundle:
    """Manages the creation and packaging of spell bundles."""

    ELDER_FUTHARK = [
        "ᚠ", "ᚢ", "ᚦ", "ᚨ", "ᚱ", "ᚲ", "ᚷ", "ᚹ", "ᚺ", "ᚾ", "ᛁ", "ᛃ", "ᛇ", "ᛈ", "ᛉ", "ᛊ",
        "ᛏ", "ᛒ", "ᛖ", "ᛗ", "ᛚ", "ᛜ", "ᛞ", "ᛟ"
    ]
    
    YOUNGER_FUTHARK = [
        "ᚠ", "ᚢ", "ᚦ", "ᚬ", "ᚱ", "ᚴ", "ᚼ", "ᚾ", "ᛁ", "ᛅ", "ᛋ", "ᛏ", "ᛒ", "ᛘ", "ᛚ", "ᛦ"
    ]
    
    MEDIEVAL_RUNES = [
        "ᛆ", "ᛒ", "ᛍ", "ᛑ", "ᛂ", "ᛓ", "ᛄ", "ᚻ", "ᛌ", "ᛕ", "ᛖ", "ᛗ", "ᚿ", "ᚮ", "ᛔ", "ᛩ",
        "ᛪ", "ᚱ", "ᛌ", "ᛐ", "ᚢ", "ᚡ", "ᚥ", "ᛨ"
    ]
    
    OGHAM = [
        "ᚁ", "ᚂ", "ᚃ", "ᚄ", "ᚅ", "ᚆ", "ᚇ", "ᚈ", "ᚉ", "ᚊ", "ᚋ", "ᚌ", "ᚍ", "ᚎ", "ᚏ", "ᚐ",
        "ᚑ", "ᚒ", "ᚓ", "ᚔ", "ᚕ"
    ]
    
    ALL_RUNES = ELDER_FUTHARK + YOUNGER_FUTHARK + MEDIEVAL_RUNES + OGHAM

    # TODO: See if this can just be passed from spellcraft
    def __init__(self, path: Path):
        """Initialize SpellBundle with a path."""
        self.path = Path(path)
        self.spell_dir = self.path  # Maintain compatibility with previous code
        self.config: Optional[Dict[str, Any]] = None
        self.temp_dir: Optional[Path] = None
        self.tome_dir = Path(SANCTUM_PATH) / '.tome'
        self.tome_dir.mkdir(parents=True, exist_ok=True)

    def _generate_spell_sigil(self, config: Dict[str, Any], sigil_hash: Optional[str] = None) -> Tuple[str, Path]:
        """
        Generate a sigil for a spell bundle.
        
        Args:
            config (Dict[str, Any]): Spell configuration
            sigil_hash (Optional[str]): Predefined hash for sigil generation
        
        Returns:
            Tuple[str, Path]: Generated sigil hash and sigil file path
        """
        # Use provided hash or generate a new one
        if not sigil_hash:
            sigil_hash = Sigildry.generate_sigil_hash(
                spell_name=config['name'],
                description=config.get('description', ''),
                spell_type=config.get('type', 'generic'),
                version=config.get('version', '1.0.0'),
                entry_point=config.get('entry_point', ''),
                shell_type=config.get('shell_type', ''),
                spell_dir=self.spell_dir
            )
        
        # Generate sigil path
        sigil_path = self.spell_dir / f"{config['name']}_sigil.svg"
        
        # Generate sigil
        print(f"- Generating sigil at: {sigil_path}")
        Sigildry.generate_sigil_from_spell(self.spell_dir, sigil_hash, sigil_path)
        
        return sigil_hash, sigil_path

    def create(self, output_dir: Optional[Path] = None) -> Path:
        """
        Create a spell bundle from the spell directory.
        
        Args:
            output_dir (Optional[Path]): Optional directory to save the spell bundle.
                                         If not provided, uses the default .tome directory.
        
        Returns:
            Path: Path to the created spell bundle
        """
        destination_dir = output_dir or self.tome_dir
        return self.create_bundle(destination_dir)

    def create_bundle(self, destination_dir: Path) -> Path:
        """Create a spell bundle from a directory with sigil."""
        if not self.is_valid_spell_dir:
            raise ValueError(f"Invalid spell directory: {self.spell_dir}")
            
        # Verify configuration and assets
        config = self.load_config()
        self.verify_assets()
        
        # Generate sigil
        sigil_hash, sigil_path = self._generate_spell_sigil(config)
        
        # Update spell.yaml with the hash
        config['sigil_hash'] = sigil_hash
        yaml_path = self.spell_dir / 'spell' / 'spell.yaml'
        with open(yaml_path, 'w') as f:
            yaml.safe_dump(config, f, default_flow_style=False)
        
        # Create bundle path
        bundle_name = f"{config['name']}.spell"
        bundle_path = destination_dir / bundle_name
        
        # Create the zip bundle
        with zipfile.ZipFile(bundle_path, 'w', zipfile.ZIP_DEFLATED) as zf:
            # Create metadata
            metadata = {
                "name": config["name"],
                "description": config["description"],
                "created_at": datetime.now().isoformat(),
                "entry_point": config["entry_point"],
                "shell_type": config.get("shell_type", "python"),
                "type": config.get("type", "bundled"),
                "version": config.get("version", "1.0.0"),
                "sigil_hash": sigil_hash,
                "dependencies": config.get('dependencies', {'python': []})
            }
            
            # Add metadata
            zf.writestr('spell.json', json.dumps(metadata, indent=2))
            
            # Add all files preserving directory structure
            for file_path in self.spell_dir.rglob('*'):
                if file_path.is_file():
                    arcname = file_path.relative_to(self.spell_dir)
                    zf.write(file_path, arcname)
        
        return bundle_path

    def extract_bundle(self, extract_dir: Optional[Path] = None) -> Tuple[Path, Dict[str, Any]]:
        """Extract a bundled spell and return the temp directory and metadata."""
        if not self.spell_dir.suffix == '.spell' or not zipfile.is_zipfile(self.spell_dir):
            raise ValueError(f"Not a valid spell bundle: {self.spell_dir}")
            
        if extract_dir is None:
            temp_dir = Path(tempfile.mkdtemp(prefix='magi_spell_'))
            extract_dir = temp_dir
            
        with zipfile.ZipFile(self.spell_dir) as zf:
            zf.extractall(extract_dir)
            with open(extract_dir / 'spell.json') as f:
                metadata = json.load(f)
            
        return extract_dir, metadata

    def cleanup(self):
        """Clean up temporary files."""
        if hasattr(self, 'temp_dir') and self.temp_dir and self.temp_dir.exists():
            shutil.rmtree(self.temp_dir)

    def load_config(self) -> Dict[str, Any]:
        """Load and validate the spell configuration."""
        config_path = self.spell_dir / 'spell' / 'spell.yaml'
        if not config_path.exists():
            raise ValueError(f"No spell.yaml found in {self.spell_dir}")
            
        with open(config_path) as f:
            config = yaml.safe_load(f)
            
        # Basic validation
        required_fields = ['name', 'version', 'description', 'type', 'entry_point']
        missing = [field for field in required_fields if field not in config]
        if missing:
            raise ValueError(f"Missing required fields in spell.yaml: {', '.join(missing)}")
            
        return config
    
    def verify_assets(self) -> bool:
        """Verify all required assets exist."""
        config = self.load_config()
        for asset in config.get('assets', []):
            asset_path = self.spell_dir / asset['path']
            if asset.get('required', False) and not asset_path.exists():
                raise ValueError(f"Required asset missing: {asset['path']}")
        return True
    
    def create(self, spell_name: str, nested_dir: Path, sigil_hash: Optional[str] = None) -> Path:
        """
        Create a spell bundle from a directory.
        
        Args:
            spell_name (str): Name of the spell
            nested_dir (Path): Directory containing spell files
            sigil_hash (Optional[str]): Optional predefined hash for sigil generation
        
        Returns:
            Path: Path to the created spell bundle
        """
        # Load configuration
        config_path = nested_dir / 'spell.yaml'
        if not config_path.exists():
            raise ValueError(f"No spell.yaml found in {nested_dir}")
        
        with open(config_path) as f:
            config = yaml.safe_load(f)
        
        # Ensure config has required fields
        config.setdefault('name', spell_name)
        
        # Generate sigil
        sigil_hash, sigil_path = self._generate_spell_sigil(config, sigil_hash)
        
        # Create bundle
        bundle_path = self.tome_dir / f"{spell_name}.spell"
        
        with zipfile.ZipFile(bundle_path, 'w', zipfile.ZIP_DEFLATED) as zf:
            # Add all files from spell directory first
            print("- Adding files to bundle:")
            for file_path in nested_dir.rglob('*'):
                if file_path.is_file():
                    try:
                        arcname = file_path.relative_to(nested_dir)
                        print(f"  Adding: {arcname}")
                        # Read file content and add to zip to avoid file locking
                        content = file_path.read_bytes()
                        zf.writestr(str(arcname), content)
                    except Exception as e:
                        print(f"Warning: Could not add file {file_path}: {e}")
            
            # Generate sigil ONCE and add to bundle
            sigil_path = nested_dir / f"{spell_name}_sigil.svg"
            print(f"- Generating sigil at: {sigil_path}")
            Sigildry.generate_sigil_from_spell(nested_dir, sigil_hash, sigil_path)
            
            # Add sigil to bundle
            sigil_name = f"{spell_name}_sigil.svg"
            with open(sigil_path, 'rb') as sigil_file:
                zf.writestr(sigil_name, sigil_file.read())
            
            # Store the hash in metadata and add metadata last
            metadata = {
                "name": config['name'],
                "description": config.get('description', ''),
                "created_at": datetime.now().isoformat(),
                "entry_point": config.get('entry_point', ''),
                "shell_type": config.get('shell_type', 'python'),
                "type": config.get('type', 'generic'),
                "version": config.get('version', '1.0.0'),
                "sigil_hash": sigil_hash,
                "dependencies": config.get('dependencies', {'python': []})
            }
            zf.writestr('spell.json', json.dumps(metadata, indent=2))
        
        return bundle_path

    @classmethod
    def create_spell_bundle(cls, 
                          spell_name: str, 
                          spell_type: Union[SpellType, str], 
                          shell_type: Union[ShellType, str],
                          entry_point: str, 
                          description: str, 
                          spell_dir: Path,
                          verify_structure: bool = True) -> Path:
        # Normalize types
        if isinstance(spell_type, str):
            spell_type = getattr(SpellType, spell_type.upper(), SpellType.SCRIPT)
        if isinstance(shell_type, str):
            shell_type = getattr(ShellType, shell_type.upper(), ShellType.PYTHON)
            
        # Create metadata
        metadata = {
            "name": spell_name,
            "description": description,
            "created_at": datetime.now().isoformat(),
            "entry_point": entry_point,
            "shell_type": shell_type,
            "type": spell_type,
            "version": "1.0.0",
            "dependencies": {'python': []}
        }
        
        # Create bundle path
        bundle_path = Path(SANCTUM_PATH) / '.tome' / f'{spell_name}.spell'

        try:
            # Create zip bundle
            with zipfile.ZipFile(bundle_path, 'w', zipfile.ZIP_DEFLATED) as zf:
                # Add all files from spell directory first
                print("- Adding files to bundle:")
                for file_path in spell_dir.rglob('*'):
                    if file_path.is_file():
                        try:
                            arcname = file_path.relative_to(spell_dir)
                            print(f"  Adding: {arcname}")
                            # Read file content and add to zip to avoid file locking
                            content = file_path.read_bytes()
                            zf.writestr(str(arcname), content)
                        except Exception as e:
                            print(f"Warning: Could not add file {file_path}: {e}")
                
                # Generate sigil ONCE and add to bundle
                sigil_path = spell_dir / f"{spell_name}_sigil.svg"
                print(f"- Generating sigil at: {sigil_path}")
                sigil_hash = Sigildry.generate_sigil_hash(
                    spell_name=spell_name,
                    description=description,
                    spell_type=spell_type,
                    version="1.0.0",
                    entry_point=entry_point,
                    shell_type=shell_type,
                    spell_dir=spell_dir
                )
                Sigildry.generate_sigil_from_spell(spell_dir, sigil_hash, sigil_path)
                
                # Add sigil to bundle
                sigil_name = f"{spell_name}_sigil.svg"
                with open(sigil_path, 'rb') as sigil_file:
                    zf.writestr(sigil_name, sigil_file.read())
                
                # Store the hash in metadata and add metadata last
                metadata['sigil_hash'] = sigil_hash
                zf.writestr('spell.json', json.dumps(metadata, indent=2))

                # Update spell.yaml with the hash
                yaml_path = spell_dir / 'spell' / 'spell.yaml'
                if yaml_path.exists():
                    with open(yaml_path) as f:
                        yaml_config = yaml.safe_load(f)
                    yaml_config['sigil_hash'] = sigil_hash
                    with open(yaml_path, 'w') as f:
                        yaml.safe_dump(yaml_config, f, default_flow_style=False)

        except Exception as e:
            if bundle_path.exists():
                bundle_path.unlink()  # Clean up failed bundle
            raise

        print(f"Bundle created at: {bundle_path}")
        return bundle_path

    @classmethod
    def _verify_spell_directory(cls, spell_dir: Path):
        """
        Verify the structure of the spell directory.
        
        Checks:
        - spell.yaml exists
        - Validates basic spell configuration
        """
        # Check for spell.yaml
        spell_yaml = spell_dir / 'spell.yaml'
        if not spell_yaml.exists():
            raise ValueError(f"Missing spell.yaml in {spell_dir}")
        
        # Optional: Add more validation checks here
        # For example, check required keys in spell.yaml, validate entry point, etc.

    @property
    def is_valid_spell_dir(self) -> bool:
        """Check if the directory contains a valid spell.yaml."""
        config_path = self.spell_dir / 'spell' / 'spell.yaml'
        return config_path.exists()
```
/spellcraft/spell_parse.py: 
```
# magi_cli/modules/spell_parse.py
import os
import json
import zipfile
import tempfile
import hashlib
import subprocess
import sys
import click  # Ensure click is imported
import shutil
from pathlib import Path
from typing import Tuple, Dict, Any, Optional, List
from magi_cli.spells import SANCTUM_PATH
from magi_cli.loci.sigildry import Sigildry

class SpellParser:
    """Parser for spell bundles with enhanced validation."""
    
    # Required metadata fields
    REQUIRED_FIELDS = ['name', 'version', 'description', 'type', 'entry_point']
    ALLOWED_TYPES = ['bundled', 'macro', 'script']  # Updated to include 'script'
    ALLOWED_SHELLS = ['python', 'bash', 'shell']
    ALLOWED_EXTENSIONS = ['.py', '.sh', '.spell', '.fiat']  # Added extensions list
    
    @staticmethod
    def parse_bundle(spell_path: str) -> Tuple[Path, Dict]:
        """
        Parse a spell bundle into a temporary directory and return the path and metadata.
        """
        import tempfile
        import zipfile
        import yaml  # Make sure yaml is imported
        import json  # Import json for spell.json
        import os

        # Create a temporary directory
        temp_dir = Path(tempfile.mkdtemp(prefix='magi_spell_'))

        # Extract the spell bundle
        with zipfile.ZipFile(spell_path, 'r') as zip_ref:
            zip_ref.extractall(temp_dir)

        # Initialize metadata
        metadata = {}

        # Load spell.yaml or spell.json
        yaml_path = temp_dir / 'spell' / 'spell.yaml'
        json_path = temp_dir / 'spell' / 'spell.json'

        if yaml_path.exists():
            with open(yaml_path, 'r') as f:
                config = yaml.safe_load(f)
                metadata = SpellParser._convert_yaml_to_metadata(config)
        elif json_path.exists():
            with open(json_path, 'r') as f:
                config = json.load(f)
                metadata = SpellParser._convert_yaml_to_metadata(config)
        else:
            raise FileNotFoundError("No metadata file (spell.yaml or spell.json) found in the spell.")

        # Verify spell sigil using Sigildry
        sigil_verification = Sigildry.verify_sigil(spell_path)
        
        # Add sigil verification details to metadata
        metadata['sigil_verification'] = {
            'status': sigil_verification.get('verification_status', 'Unknown'),
            'details': sigil_verification.get('details', 'No details'),
            'verified': sigil_verification.get('verified', False),
            'current_hash': sigil_verification.get('current_hash'),
            'stored_hash': sigil_verification.get('stored_hash')
        }

        # Validate metadata
        SpellParser._validate_metadata(metadata)

        # Return the temporary directory and metadata
        return temp_dir, metadata
                
    @staticmethod
    def _validate_metadata(metadata: Dict[str, Any]) -> None:
        """Validate spell metadata contains required fields and valid values."""
        # Allow either entry_point or main_script
        if 'main_script' in metadata and 'entry_point' not in metadata:
            metadata['entry_point'] = metadata['main_script']
        
        # Check required fields
        missing = [field for field in SpellParser.REQUIRED_FIELDS if field not in metadata]
        if missing:
            raise ValueError(f"Missing required metadata fields: {', '.join(missing)}")
            
        # Add type validation that supports all spell types    
        if metadata.get('type') not in SpellParser.ALLOWED_TYPES:
            raise ValueError(f"Invalid spell type: {metadata.get('type')}")
            
        if metadata.get('shell_type') not in SpellParser.ALLOWED_SHELLS:
            raise ValueError(f"Invalid shell type: {metadata.get('shell_type')}")
            
        # Check entry point extension
        entry_point = Path(metadata['entry_point'])
        if entry_point.suffix not in SpellParser.ALLOWED_EXTENSIONS:
            raise ValueError(f"Invalid entry point file type: {metadata['entry_point']}")
            
        # Validate dependencies format if present
        if 'dependencies' in metadata:
            if not isinstance(metadata['dependencies'], dict):
                raise ValueError("Dependencies must be a dictionary")
            if 'python' in metadata['dependencies'] and not isinstance(metadata['dependencies']['python'], list):
                raise ValueError("Python dependencies must be a list")

    @staticmethod
    def _convert_yaml_to_metadata(config: Dict[str, Any]) -> Dict[str, Any]:
        """Convert legacy spell.yaml format to standardized metadata."""
        # Handle requires field - ensure it's a list
        requires = []
        if 'requires' in config:
            if isinstance(config['requires'], list):
                requires = config['requires']
            elif isinstance(config['requires'], str):
                requires = [config['requires']]
                
        # Create dependencies dict with python key if we have requires
        dependencies = {'python': requires} if requires else {}
        
        metadata = {
            'name': config.get('name'),
            'version': config.get('version', '1.0.0'),
            'description': config.get('description', ''),
            'type': config.get('type', 'bundled'),
            'shell_type': config.get('shell_type', 'python'),
            'entry_point': config.get('entry_point'),
            'parameters': config.get('parameters', {}),
            'dependencies': dependencies,
            'created_at': '',  # Set during bundling
            'sigil_hash': None  # Calculated during bundling
        }
        return metadata

    @staticmethod
    def check_dependencies(
        dependencies: Dict[str, List[str]], 
        verbose: bool = False
    ) -> bool:
        """
        Check if required dependencies are installed.
        
        Args:
            dependencies (Dict[str, List[str]]): Dictionary of dependencies
            verbose (bool, optional): Show detailed dependency information
        
        Returns:
            bool: True if all dependencies are satisfied, False otherwise
        """
        try:
            import importlib.util
            
            # If no dependencies, return True
            if not dependencies or 'python' not in dependencies:
                return True
            
            python_deps = dependencies['python']
            
            # If no Python dependencies, return True
            if not python_deps:
                return True
            
            # Track missing dependencies
            missing_deps = []
            
            # Check each dependency
            for dep in python_deps:
                # Extract package name (handle various version specifiers)
                pkg_name = dep.split('>=')[0].split('~=')[0].split('==')[0].strip()
                
                try:
                    spec = importlib.util.find_spec(pkg_name)
                    if spec is None:
                        missing_deps.append(dep)
                except ImportError:
                    missing_deps.append(dep)
            
            # Verbose output for dependencies
            if verbose and missing_deps:
                click.echo(click.style("\nDependency Check:", fg='bright_cyan', bold=True))
                click.echo(click.style("  Missing Packages:", fg='bright_red'))
                for dep in missing_deps:
                    click.echo(f"    - {dep}")
            
            # If missing dependencies, prompt to install
            if missing_deps:
                if verbose:
                    install_prompt = click.style("  Would you like to install these dependencies?", fg='bright_white')
                    if click.confirm(install_prompt, default=True):
                        try:
                            import subprocess
                            subprocess.check_call([sys.executable, '-m', 'pip', 'install'] + missing_deps)
                            click.echo(click.style("  Dependencies installed successfully!", fg='bright_green'))
                            return True
                        except subprocess.CalledProcessError:
                            click.echo(click.style("  Failed to install dependencies", fg='bright_red'))
                            return False
                return False
            
            return True
        
        except Exception as e:
            if verbose:
                click.echo(click.style(f"Dependency check error: {e}", fg='bright_red'))
            return False

    @classmethod
    def find_spell_file(cls, spell_name: str) -> Path:
        """
        Find the spell file in the .tome directory.
        
        Args:
            spell_name (str): Name of the spell to find
        
        Returns:
            Path: Full path to the spell file
        """
        # Ensure spell name has .spell extension
        if not spell_name.endswith('.spell'):
            spell_name += '.spell'
        
        # Potential paths to search
        potential_paths = [
            Path(SANCTUM_PATH) / '.tome' / spell_name,  # Exact match in .tome
            Path(SANCTUM_PATH) / '.tome' / f"{spell_name.split('.')[0]}.spell",  # Alternate case
            Path(os.path.expanduser('~')) / '.sanctum' / '.tome' / spell_name,  # User home directory
        ]
        
        # Search through potential paths
        for path in potential_paths:
            if path.exists():
                return path
        
        # If no spell found, raise an error
        raise FileNotFoundError(f"Could not find spell '{spell_name}' in .tome directory")

    @classmethod
    def execute_spell_file(
        cls, 
        spell_name: str, 
        *args: str, 
        verbose: int = 0
    ) -> bool:
        """
        Execute a spell from the .tome directory.
        
        Args:
            spell_name (str): Name of the spell to execute
            *args (str): Additional arguments to pass to the spell
            verbose (int, optional): Verbosity level. 0 = silent, 1 = basic info, 2 = detailed info
        
        Returns:
            bool: True if spell execution was successful, False otherwise
        """
        try:
            # Resolve spell path in .tome directory
            tome_path = Path(SANCTUM_PATH) / '.tome'
            spell_path = tome_path / f"{spell_name}.spell"
            
            if not spell_path.exists():
                click.echo(f"Error: Spell '{spell_name}' not found in tome.")
                return False
            
            # Verify spell sigil using Sigildry
            sigil_verification = Sigildry.verify_sigil(spell_path)
            
            # Parse the spell bundle
            try:
                if verbose >= 2:
                    click.echo("\nExtracting spell bundle:")
                    click.echo(f"  From: {spell_path}")
                
                temp_dir, metadata = SpellParser.parse_bundle(spell_path)
                
                if verbose >= 2:
                    click.echo(f"  To: {temp_dir}")
                    click.echo("\nListing extracted files:")
                    for root, dirs, files in os.walk(temp_dir):
                        rel_path = os.path.relpath(root, temp_dir)
                        if rel_path == '.':
                            for f in files:
                                click.echo(f"  - {f}")
                        else:
                            for f in files:
                                click.echo(f"  - {rel_path}/{f}")
            except Exception as e:
                click.echo(f"Error parsing spell bundle: {e}")
                return False
            
            # Level 1 verbosity (basic info)
            if verbose >= 1:
                click.echo(f"Executing Spell: {metadata.get('name', spell_name)}")
                click.echo(f"Description: {metadata.get('description', 'No description')}")
                click.echo(f"Type: {metadata.get('type', 'Unknown')}")
                click.echo(f"Shell Type: {metadata.get('shell_type', 'Unknown')}")
            
            # For other spell types, locate the entry point script
            entry_point_name = metadata.get('entry_point')
            if not entry_point_name:
                click.echo("Error: No entry point found in spell metadata.")
                return False
            
            # Find the actual entry point file
            entry_point_candidates = [
                temp_dir / 'spell' / entry_point_name,  # Primary location in spell/
                temp_dir / entry_point_name,  # Fallback to root
                temp_dir / 'spell' / 'spell' / entry_point_name  # Legacy location
            ]
            
            if verbose >= 2:
                click.echo("\nSearching for entry point:")
                for path in entry_point_candidates:
                    click.echo(f"  Checking: {path}")
                    if path.exists():
                        click.echo(f"  Found at: {path}")
                        break
            
            entry_point = next((path for path in entry_point_candidates if path.exists()), None)
            
            if not entry_point:
                click.echo(f"Error: Entry point {entry_point_name} not found.")
                return False
            
            # Make the script executable if it's a shell script
            if entry_point.suffix == '.sh':
                entry_point.chmod(0o755)
            
            # Determine execution method based on file type
            shell_type = metadata.get('shell_type', 'python')
            
            try:
                if shell_type == 'python':
                    # Use subprocess to run Python script
                    result = subprocess.run(
                        [sys.executable, str(entry_point), *args], 
                        capture_output=True, 
                        text=True
                    )
                    
                    # Handle Python script output
                    if result.stdout:
                        click.echo(result.stdout)
                    if result.stderr:
                        click.echo(result.stderr, err=True)
                    
                    # Check return code
                    if result.returncode != 0:
                        click.echo(f"Python spell execution failed with code {result.returncode}")
                        return False
                
                elif shell_type in ['bash', 'shell']:
                    # Use os.system to run shell script
                    exit_code = os.system(f"bash {entry_point}")
                    
                    if exit_code != 0:
                        click.echo(f"Shell spell execution failed with code {exit_code}")
                        return False
                
                else:
                    click.echo(f"Unsupported shell type: {shell_type}")
                    return False
            
            except Exception as e:
                click.echo(f"Execution error: {e}")
                return False
            
            # Level 2 verbosity (detailed metadata)
            if verbose >= 2:
                click.echo("\nDetailed Spell Metadata:")
                for key, value in metadata.items():
                    # Skip empty or None values
                    if value is None or (isinstance(value, (str, list, dict)) and len(value) == 0):
                        continue
                    
                    # Skip code display and sigil verification (will show separately)
                    if key in ['code', 'sigil_verification']:
                        continue
                    
                    # Special handling for nested dictionaries
                    if isinstance(value, dict):
                        click.echo(f"  {click.style(key.upper(), fg='bright_cyan', bold=True)}:")
                        for sub_key, sub_value in value.items():
                            # Skip empty or None sub-values
                            if sub_value is not None and not (isinstance(sub_value, (str, list, dict)) and len(sub_value) == 0):
                                click.echo(f"    {click.style(sub_key + ':', fg='bright_white')} {sub_value}")
                    else:
                        click.echo(f"  {click.style(key.upper() + ':', fg='bright_cyan')} {value}")
                
                # Add sigil verification details
                click.echo("\n  SIGIL VERIFICATION:")
                verification_details = sigil_verification
                for sub_key, sub_value in verification_details.items():
                    if sub_key != 'metadata':  # Skip nested metadata
                        click.echo(f"    {click.style(sub_key.upper() + ':', fg='bright_white')} {sub_value}")
            
            return True
        
        except Exception as e:
            click.echo(f"Unexpected error executing spell: {e}")
            return False
        finally:
            # Clean up temporary directory
            import shutil
            if 'temp_dir' in locals() and Path(temp_dir).exists():
                shutil.rmtree(temp_dir, ignore_errors=True)

    @staticmethod
    def execute_python_file(script_path: str, args=None, verbose: bool = False) -> bool:
        """
        Execute a Python script with optional arguments.
        
        Args:
            script_path (str): Path to the Python script
            args (list, optional): Arguments to pass to the script
            verbose (bool, optional): Show detailed execution information
        
        Returns:
            bool: True if execution was successful, False otherwise
        """
        try:
            # Prepare the command
            cmd = [sys.executable, script_path] + (args or [])
            
            if verbose:
                # Detailed command execution logging
                click.echo(click.style("Python Script Execution:", fg='bright_cyan', bold=True))
                click.echo(f"  {click.style('Script Path:', fg='bright_white')} {script_path}")
                click.echo(f"  {click.style('Command:', fg='bright_white')} {' '.join(cmd)}")
            
            # Run the script
            result = subprocess.run(cmd, capture_output=verbose, text=verbose)
            
            # If verbose, show output
            if verbose and result.stdout:
                click.echo(click.style("\nScript Output:", fg='bright_cyan', bold=True))
                click.echo(result.stdout)
            
            # Check for errors
            if result.returncode != 0 and verbose:
                click.echo(click.style("\nScript Execution Error:", fg='bright_red', bold=True))
                click.echo(result.stderr)
                return False
            
            return True
        
        except subprocess.CalledProcessError:
            if verbose:
                click.echo(click.style("Script Execution Failed", fg='bright_red', bold=True))
            return False

    @staticmethod
    def execute_bash_file(script_path: str, verbose: bool = False) -> bool:
        """
        Execute a bash script using the system shell.
        
        Args:
            script_path (str): Path to the bash script
            verbose (bool, optional): Show detailed execution information
        
        Returns:
            bool: True if execution was successful, False otherwise
        """
        try:
            # Make script executable
            Path(script_path).chmod(0o755)
            
            if verbose:
                click.echo(click.style("Bash Script Execution:", fg='bright_cyan', bold=True))
                click.echo(f"  {click.style('Script Path:', fg='bright_white')} {script_path}")
            
            # Execute using system shell
            exit_code = os.system(f"bash {script_path}")
            
            if exit_code != 0:
                if verbose:
                    click.echo(click.style("\nScript Execution Error:", fg='bright_red', bold=True))
                    click.echo(f"Exit code: {exit_code}")
                return False
            
            return True
            
        except Exception as e:
            if verbose:
                click.echo(click.style("Failed to execute script", fg='bright_red', bold=True))
                click.echo(str(e))
            return False
```
/spellcraft/__init__.py: 
```

```
/__init__.py: 
```

```
